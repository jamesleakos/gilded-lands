import GameState from '../Game/GameState';
import PlayerInfo from './PlayerInfo';
import PlayerQueueline from '../Queueline/PlayerQueueline/PlayerQueueline';
import ServerRequestsTargetsPlayerQueueline from '../Queueline/PlayerQueueline/PlayerQueuelines/ServerRequestsTargetsPlayerQueueline';
import TargetInfo from '../Target/TargetInfo';
import RuntimeEffect from '../Effect/RuntimeEffect';
import PayResourceCost from '../PayResourceCost/PayResourceCost';
import StartGameMessage from '../Networking/GameLoop/Game/StartGameMessage';
import EndGameMessage from '../Networking/GameLoop/Game/EndGameMessage';
import ServerMovedCardMessage from '../Networking/Cards/Move/ServerMovedCardMessage';
import ServerCardMovedRowMessage from '../Networking/Cards/MovedRow/ServerCardMovedRowMessage';
import NextPhaseReadyMessage from '../Networking/GameLoop/PhaseAndQueue/NextPhaseReadyMessage';
import QueueStartedMessage from '../Networking/GameLoop/PhaseAndQueue/QueueStartedMessage';
import { NetworkProtocol } from '../../Enums/NetworkProtocol';
import { ClientMessage } from '../Networking/MessageBase';
import ServerSendingGamestateForRejoin from '../Networking/Connection/ServerSendingGamestateForRejoinMessage';
import CardPlayedMessage from '../Networking/Cards/Play/CardPlayedMessage';
import CreatureAttackedMessage from '../Networking/Attacking/CreatureAttackedMessage';
import AbilityActivatedMessage from '../Networking/Abilities/AbilityActivatedMessage';
import GetTargetsFromPlayerMessage from '../Networking/Abilities/GetTargetsFromPlayerMessage';
import OpponentDrewCardsMessage from '../Networking/Cards/Draw/OpponentDrewCardsMessage';
import PlayerDrewCardsMessage from '../Networking/Cards/Draw/PlayerDrewCardsMessage';
import { ZoneEnum } from '../../Enums/Zone';
import CardUpgradedMessage from '../Networking/Upgrades/CardUpgradedMessage';
import TargetCriteria from '../Target/TargetCriteria';
import LandExploredMessage from '../Networking/Land/LandExporedMessage';
import RuntimeLandTile from '../RealmsAndLand/LandTile/RuntimeLandTile';
declare class Player {
    sendToServer: (messageName: NetworkProtocol, message: ClientMessage) => void;
    _sendToServer: (messageName: string, message: ClientMessage) => void;
    gameState: GameState;
    userId: string;
    queue: PlayerQueueline[];
    queueMessages: ClientMessage[];
    requestLine: ServerRequestsTargetsPlayerQueueline;
    readyForQueue: boolean;
    queueReadyToRun: boolean;
    currentQueueIndex: number;
    numQueuelinesInBatch: number;
    numQueuelinesTotal: number;
    numQueuelinesAlreadyProcessed: number;
    breakingBeforeEndOfQueue: boolean;
    amBreakingPlayer: boolean;
    targetInfoCode: number;
    returningCardInstanceId: number;
    returningEffect: RuntimeEffect;
    returningTargetTypes: TargetCriteria[];
    constructor(_sendToServer: (messageName: string, message: ClientMessage) => void);
    clone(): Player;
    getPlayerInfo(): PlayerInfo;
    getOpponentInfo(): PlayerInfo;
    onStartGame(msg: StartGameMessage): void;
    onEndGame(msg: EndGameMessage): void;
    onGamestateForRejoin(msg: ServerSendingGamestateForRejoin): void;
    fetchUpdatedGamestate(): void;
    onStartPhase(msg: NextPhaseReadyMessage): void;
    receivedQueueStartedMessage(msg: QueueStartedMessage): void;
    startQueue(): void;
    returnPlayersFromQueue(): Player[];
    runNextQueueline(): void;
    finishedActions(): void;
    queuePlayCard(cardInstanceId: number, boardZoneEnum: ZoneEnum, selectedCosts: PayResourceCost[], battlecryIndex: number, targetInfoList: TargetInfo[]): void;
    cancelPlayCard(cardInstanceId: number): void;
    receivedPlayCardMessage(msg: CardPlayedMessage): void;
    onCardPlayed(sourcePlayerUserId: any, sourceCardInstanceId: any, targetInfoList: any[], originZoneZoneEnum: ZoneEnum, destinationZoneZoneEnum: ZoneEnum): void;
    onPlayerDrewCards(msg: PlayerDrewCardsMessage): void;
    onOpponentDrewCards(msg: OpponentDrewCardsMessage): void;
    onCardMoved(msg: ServerMovedCardMessage): void;
    receivedCardMovedRowMessage(msg: ServerCardMovedRowMessage): void;
    onCardMovedRow(movedCardInstanceId: number, originZoneEnum: ZoneEnum, destinationZoneEnum: ZoneEnum): void;
    onCardUpgraded(upgradingCardInstanceId: number, targetInfoList: TargetInfo[], upgradeLevel: number): void;
    queueUpgradeCard(currentCardInstanceId: number, currentTrackingIndex: number, currentEffect: RuntimeEffect, upgradeLevel: number, useEffect: boolean): void;
    receivedUpgradeCardMessageFromServer(msg: CardUpgradedMessage): void;
    queueAttack(attackingCardInstanceId: number, attackedCardInstanceId: number): void;
    cancelAttack(attackingCardInstanceId: number): void;
    receivedAttackMessage(msg: CreatureAttackedMessage): void;
    onCreatureAttacked(attackingCardInstanceId: number, attackedCardInstanceId: number): void;
    queueBlock(blockingCardInstanceId: number, blockedCardInstanceId: number): void;
    cancelBlock(blockingCardInstanceId: number): void;
    changeBlockOrder(blockingCardInstanceId: number, newBlockOrder: number): void;
    queueActivateAbility(sourceEntityInstanceId: number, abilityIndex: number, paidCosts: PayResourceCost[], targetInfoList: TargetInfo[]): void;
    receivedActivateAbilityMessageFromServer(msg: AbilityActivatedMessage): void;
    onActivateAbility(sourceEntityInstanceId: number, targetInfoList: TargetInfo[], abilityIndex: number): void;
    receivedTargetsRequestedMessage(msg: GetTargetsFromPlayerMessage): void;
    onServerRequestsTargets(effect: RuntimeEffect, cardInstanceId: number, targetCriterias: TargetCriteria[], targetInfoCode: number): void;
    returnTargetsToServer(targetInfo: TargetInfo[]): void;
    exploreLand(landTile: RuntimeLandTile): void;
    onLandExplored(msg: LandExploredMessage): void;
}
export default Player;
