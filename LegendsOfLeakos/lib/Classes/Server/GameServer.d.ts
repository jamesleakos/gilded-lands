import GameState from '../Game/GameState';
import ServerQueueline from '../Queueline/ServerQueueline/ServerQueueline';
import ServerHandler from './ServerHandler';
import PlayerInfo from '../Player/PlayerInfo';
import Phase from '../Phase/Phase';
import { NetworkProtocol } from '../../Enums/NetworkProtocol';
import { ZoneEnum } from '../../Enums/Zone';
import RuntimeCard from '../Card/RuntimeCard';
import PayResourceCost from '../PayResourceCost/PayResourceCost';
import TargetInfo from '../Target/TargetInfo';
import RuntimeEffect from '../Effect/RuntimeEffect';
import RuntimeLandTile from '../RealmsAndLand/LandTile/RuntimeLandTile';
import LibraryCard from '../Card/LibraryCard';
import LibraryEnchantment from '../Enchantment/LibraryEnchantment';
import { ServerMessage } from '../Networking/MessageBase';
declare class GameServer {
    userIdToSocketId: Function;
    sendToRoom: Function;
    sendToPlayer: (messageType: NetworkProtocol, message: ServerMessage, playerUserID: string) => void;
    endGameCallback: Function;
    p0_readyToProgressPhase: boolean;
    p1_readyToProgressPhase: boolean;
    phaseList: Phase[];
    turnDuration: number;
    gameState: GameState;
    protected handlers: ServerHandler[];
    queueStarted: boolean;
    currentQueueIndex: number;
    queue: ServerQueueline[];
    targetInfoCode: number | null;
    protected gameFinished: boolean;
    constructor(players: any[], userIdToSocketId: (userId: string) => string, sendToPlayer: (messageType: string, message: any, playerUserID: string) => void, endGameCallback: Function, cardLibraryJSON: LibraryCard[], enchantmentLibraryJSON: LibraryEnchantment[]);
    getPlayerInfo: (userId: string, index: number, name: string, realmJSON: any, cardLibrary: LibraryCard[]) => PlayerInfo;
    listen(playerSockets: any): void;
    protected unlisten(playerSockets: any): void;
    startNewGame(): void;
    startGame(): void;
    endGame(): void;
    playerExploredLand(exploringPlayer: PlayerInfo, landTile: RuntimeLandTile): void;
    playerReadyForQueueExecution(readyPlayer: PlayerInfo): void;
    alreadyFightingBlockingOrMoving(cardInstanceId: number): boolean;
    queueFightCreature(clientMessageId: string, attackingCard: RuntimeCard, attackedCard: RuntimeCard, sourcePlayer: PlayerInfo, priority: number): void;
    queueActivateAbility(clientMessageId: string, card: RuntimeCard, sourcePlayerInfo: PlayerInfo, targetInfoList: TargetInfo[], paidCosts: PayResourceCost[], effect: RuntimeEffect, priority: number, abilityIndex: number): void;
    queueUpgradeCard(clientMessageId: string, cardInstanceId: number, sourcePlayerUserId: string, targetInfoList: TargetInfo[], paidCosts: PayResourceCost[], effect: RuntimeEffect, priority: number, upgradeIndex: number): void;
    queuePlayCard(clientMessageId: string, sourceCard: RuntimeCard, sourcePlayer: PlayerInfo, targetInfoList: TargetInfo[], paidCosts: PayResourceCost[], priority: number, originZoneZoneEnum: ZoneEnum, destinationZoneZoneEnum: ZoneEnum): void;
    queueCardMovedRow(clientMessageId: string, cardInstanceId: number, sourcePlayerUserId: string, priority: number, originZoneZoneEnum: ZoneEnum, destinationZoneEnum: ZoneEnum): void;
    static queueSorter(a: ServerQueueline, b: ServerQueueline): number;
    startTheQueue(): void;
    executeNextQueueline(): void;
    endQueue(): void;
    startPhase(): void;
    endPhase(): void;
    playerFinishRecruitmentPhase(player: PlayerInfo): void;
    moveBackAttackingCards(): void;
    drawCards(player: PlayerInfo, numberOfCards: number): void;
    cardBlocking(blockingCard: RuntimeCard, blockedCard: RuntimeCard, blockOrder: number): void;
    reorderBlockingCard(blockingCard: RuntimeCard, originalBlockOrder: number): void;
    stopCardBlocking(blockingCardInstance: number): void;
}
export default GameServer;
